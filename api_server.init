#!/bin/bash

### BEGIN INIT INFO
# Provides:        api_server
# Required-Start:  $network $remote_fs $syslog
# Required-Stop:   $network $remote_fs $syslog
# Default-Start:   2 3 4 5
# Default-Stop: 
# Short-Description: Start API server
### END INIT INFO

NAME="API Server"
LISTEN_IP="0.0.0.0"       # listen IP, default is 0.0.0.0
LISTEN_PORT=8888          # listen port, default is random in 8000-9000 range
SERVER="puma"             # puma, unicorn, thin are supported.. add more
ENVIRONMENT="production"  # set RACK_ENV to "production", defaults to "development"
                          # if .pd or .dev* detected in API_HOME, resets to "development"

export LISTEN_PORT

# Not needed at the moment
# detect DOCKER and use thin SERVER
#if [ "$container" == "lxc" ]; then
#	SERVER="thin"
#fi

. /lib/lsb/init-functions

PATH=/sbin:/bin:/usr/sbin:/usr/bin:/var/lib/gems/1.9.1/bin:/usr/local/bin
# a way to figure out a service home directory, no matter where it's called from
self_path="$(readlink -e $0)"
DIR="${self_path%%/${self_path##*/}}"
PRODUCT_HOME=${DIR%/*}
API_HOME=${DIR}

# set ENVIRONMENT to "development" if .pd or .dev* files are detected
[ -e $API_HOME/.pd ] || [ -e $API_HOME/.dev* ] && ENVIRONMENT="development"
[ -e $PRODUCT_HOME/.pd ] || [ -e $PRODUCT_HOME/.dev* ] && ENVIRONMENT="development"

cd $API_HOME

[ -r $API_HOME/tmp ] || mkdir $API_HOME/tmp
[ -r $API_HOME/log ] || mkdir $API_HOME/log

RED='\e[0;31m'
GREEN='\e[0;32m'
YELLOW='\e[0;33m'
PURPLE='\e[0;35m'
NC='\e[0m'

# customize few things per server
case $SERVER in
  puma)
    [ "$container" == "lxc" ] && DAEMON_FLAG=""
    PIDFILE=$API_HOME/tmp/puma.pid
    LOGFILE=$API_HOME/log/puma.log

    function start_server() {
      bundle exec puma -e ${ENVIRONMENT:-development} ${DAEMON_FLAG:-"-d"} --pidfile $PIDFILE --bind tcp://${LISTEN_IP:-127.0.0.1}:${LISTEN_PORT:-$[8000+RANDOM%1000]} --workers 2 --preload >> $LOGFILE 2>&1
      return $?
    }
    function stop_server() {
      kill $(cat $PIDFILE)
      RETVAL=$?
      rm -f $PIDFILE
      return $RETVAL
    }
    function reload_server() {
      kill -USR2 $(cat $PIDFILE)
    }
    function status_server() {
      if [ ! -r $PIDFILE ]; then
        return 1
      elif ( kill -0 $(cat $PIDFILE) 2>/dev/null); then
        return 0
      else
        rm -f $PIDFILE
        return 1
      fi
    }
  ;;
  unicorn)
    [ "$container" == "lxc" ] && DAEMON_FLAG=""
    PIDFILE=$API_HOME/tmp/unicorn.pid

    function start_server() {
      bundle exec unicorn -E production ${DAEMON_FLAG:-"-D"} -c ./unicorn.rb
      return $?
    }
    function stop_server() {
      kill $(cat $PIDFILE)
      RETVAL=$?
      rm -f $PIDFILE
      return $RETVAL
    }
    function reload_server() {
      kill -USR2 $(cat $PIDFILE)
    }
    function status_server() {
      if [ ! -r $PIDFILE ]; then
        return 1
      elif ( kill -0 $(cat $PIDFILE) 2>/dev/null); then
        return 0
      else
        rm -f $PIDFILE
        return 1
      fi
    }
  ;;
  thin)
    [ "$container" == "lxc" ] && DAEMON_FLAG=""
    PIDFILE=$API_HOME/tmp/thin.pid
    LOGFILE=$API_HOME/log/thin.log

    function start_server() {
      bundle exec thin start -e ${ENVIRONMENT:-development} ${DAEMON_FLAG:-"-d"} --port ${LISTEN_PORT:-8888} --log $LOGFILE --pid $PIDFILE
      return $?
    }
    function stop_server() {
      kill $(cat $PIDFILE)
      RETVAL=$?
      rm -f $PIDFILE
      return $RETVAL
    }
    function reload_server() {
      kill -USR2 $(cat $PIDFILE)
    }
    function status_server() {
      if [ ! -r $PIDFILE ]; then
        return 1
      elif ( kill -0 $(cat $PIDFILE) 2>/dev/null); then
        return 0
      else
        rm -f $PIDFILE
        return 1
      fi
    }
  ;;
  *)
    echo "${SERVER} not supported, bailing..."
    exit 1
  ;;
esac

case $1 in
  start)
    if $0 status > /dev/null 2>&1; then
      /bin/echo -e "${NAME} is ${GREEN}already running${NC}" >&2
      exit 0
    else
      log_daemon_msg "Starting ${NAME}" "${SERVER} on port ${LISTEN_PORT}"
      start_server
      log_end_msg $?
    fi
  ;;
  stop)
    if $0 status > /dev/null 2>&1; then
      log_daemon_msg "Stopping ${NAME}" ${SERVER}
      stop_server
      log_end_msg $?
    else
      log_daemon_msg "${NAME}/${SERVER}" "is not running"
      log_end_msg $?
    fi
  ;;
  restart)
    $0 stop
    sleep 2
    $0 start
  ;;
  reload)
    if $0 status > /dev/null 2>&1; then
      log_daemon_msg "Reloading ${NAME}" ${SERVER}
      reload_server
      log_end_msg $?
    else
      log_daemon_msg "${NAME}/${SERVER}" "is not running"
      log_end_msg $?
    fi
  ;;
  status)
   /bin/echo -en "${NAME} is.. " >&2
   if status_server; then
     /bin/echo -e "${GREEN}running${NC}" >&2
     exit 0
   else
     /bin/echo -e "${RED}not running${NC}" >&2
     exit 1
   fi
  ;;
  *)
    echo "Usage: $0 {start|stop|restart|status}" >&2
    exit 2
  ;;
esac

exit 0
